<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-cn">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScript, Css" />










<meta name="keywords" content="前端">
<meta property="og:type" content="website">
<meta property="og:title" content="噬己心以驽吾翼">
<meta property="og:url" content="https://nanchenk.github.io/index.html">
<meta property="og:site_name" content="噬己心以驽吾翼">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="噬己心以驽吾翼">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://nanchenk.github.io/"/>





  <title>噬己心以驽吾翼</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-cn">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">噬己心以驽吾翼</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://nanchenk.github.io/2018/09/06/Promise-A-标准-译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nanchen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="噬己心以驽吾翼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/Promise-A-标准-译/" itemprop="url">Promise A+ 标准(译)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-06T22:36:09+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/06/Promise-A-标准-译/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/06/Promise-A-标准-译/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><p>一个符合promise/A+规范的promise应该具备以下特征：</p>
<ol>
<li><p>描述：</p>
<ol>
<li>首先他是一个具有<span data-type="color" style="color:#FA8C16">then</span>方法的object或者function；</li>
<li>他只有<span data-type="color" style="color:#FA8C16">三种状态</span>，pending, fulfilled, rejected，只能是其中一种状态；</li>
<li>pending变为fulfilled或者rejected后不能再转变为其他状态；</li>
<li>fulfilled状态需要一个value作为异步操作的结果；</li>
<li>rejected状态需要一个reason作为拒绝的理由；</li>
<li>具有reject与fulfill<span data-type="color" style="color:#FA8C16">两种行为</span>；</li>
</ol>
</li>
<li><p>then：<span data-type="color" style="color:rgb(34, 34, 34)"><span data-type="background" style="background-color:rgba(0, 0, 0, 0.06)">promise.then(onFulfilled,onRejected)</span></span></p>
<ol>
<li>then方法接受<span data-type="color" style="color:#FA8C16">两个参数</span>： onFulfilled， onRejected;</li>
<li>当状态变为fulfilled时，执行onFulfilled；</li>
<li>当状态变为rejected时，执行onRejected；</li>
<li>onFulfilled，onRejected都为可选参数，但是只能作为function运行；</li>
<li>then可以被<span data-type="color" style="color:#FA8C16">调用多次</span>，但是一旦状态变为fulfilled/rejected，所有onFulfilled/onRejected必须按顺序执行；</li>
<li><span data-type="color" style="color:#FA8C16">then必须返回promise</span>;</li>
</ol>
</li>
<li><p>决议过程：<code>[[Resolve]](promise, x)</code></p>
<ol>
<li>promise与x不能具有相同的引用；</li>
<li>如果x是promise, 则promise与x具有相同的状态,执行对应的动作；</li>
<li>如果x是<span data-type="color" style="color:#FA8C16">复杂变量</span>（objec/function），尝试执行对应的then；</li>
<li>如果x是<span data-type="color" style="color:#FA8C16">简单变量</span>，promise 变为fulfilled状态，返回x;</li>
<li>无限递归地检测不是必需的，但是做的话要返回TypeError；</li>
</ol>
</li>
</ol>
<h1 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h1><blockquote>
<p>An open standard for sound, interoperable JavaScript promises—by implementers, for implementers.</p>
</blockquote>
<hr>
<p>一个可靠的，可交互的JavaScript promises的开放标准——由开发者自给自足</p>
<blockquote>
<p>A promise represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its <code>then</code> method, which registers callbacks to receive either a promise’s eventual value or the reason why the promise cannot be fulfilled.</p>
</blockquote>
<hr>
<p>promise表示一个异步操作的结果。使用的主要方式是通过then方法，他注册了回调函数去接受promise最后的结果或者没完成原因。</p>
<blockquote>
<p>This specification details the behavior of the <code>then</code> method, providing an interoperable base which all Promises/A+ conformant promise implementations can be depended on to provide. As such, the specification should be considered very stable. Although the Promises/A+ organization may occasionally revise this specification with minor backward-compatible changes to address newly-discovered corner cases, we will integrate large or backward-incompatible changes only after careful consideration, discussion, and testing.</p>
</blockquote>
<hr>
<p>规范详细制定了then方法的行为，提供了一个所有符合Promises/A+的实现都可以依赖的基础。因此，这个规范应该可以说是非常稳定的。虽然Promises/A+组织有可能会修订这个标准，处理一些新发现的边界情况，但是这些改动都是向后兼容的，如果要整合一个大的或者不向后的兼容的修改，一定会经过小心的考虑与决定，并且会去测试。</p>
<blockquote>
<p>Historically, Promises/A+ clarifies the behavioral clauses of the earlier Promises/A proposal, extending it to cover de facto behaviors and omitting parts that are underspecified or problematic.</p>
</blockquote>
<hr>
<p>从历史上看，Promises/A+ 澄清了Promises/A的提案，覆盖了约定俗成的行为，并且剔除了不足的或者有问题的部分。</p>
<blockquote>
<p>Finally, the core Promises/A+ specification does not deal with how to create, fulfill, or reject promises, choosing instead to focus on providing an interoperable <code>then</code> method. Future work in companion specifications may touch on these subjects.</p>
</blockquote>
<hr>
<p>最后，Promises/A+规范的核心不是去描述如何去创建，完成，拒绝promises，而是专注于提供一个可操作的then方法。未来配套的规范会去定义他们。</p>
<blockquote>
<ol>
<li><strong>Terminology</strong><br> 1.1. “promise” is an object or function with a <code>then</code> method whose behavior conforms to this specification.<br> 1.2. “thenable” is an object or function that defines a <code>then</code> method.<br> 1.3. “value” is any legal JavaScript value (including <code>undefined</code>, a thenable, or a promise).<br> 1.4. “exception” is a value that is thrown using the <code>throw</code> statement.<br> 1.5. “reason” is a value that indicates why a promise was rejected.</li>
</ol>
</blockquote>
<hr>
<ol>
<li><strong>术语</strong><br>1.1. “promise” 是一个符合此规范的object或是function。<br>   1.2. “thenable” 是一个定义了then方法的object或者function。<br>   1.3. “value” 代表了一切合法的JavaScript值（包括undefined, thenable, 或者一个promise）。<br>   1.4. “exception” 代表了通过throw语句扔出的值。<br>   1.5. “reason” 说明了promise 为什么被 rejected了的值。</li>
</ol>
<blockquote>
<ol start="2">
<li><strong>Requirements</strong><br> 2.1. Promise States<br> A promise must be in one of three states: pending, fulfilled, or rejected.<br>2.1.1. When pending, a promise:<pre><code>2.1.1.1. may transition to either the fulfilled or rejected state.
</code></pre>   2.1.2. When fulfilled, a promise:<pre><code>2.1.2.1. must not transition to any other state.
2.1.2.2. must have a value, which must not change.
</code></pre>   2.1.3. When rejected, a promise:<pre><code>2.1.3.1. must not transition to any other state.
2.1.3.2. must have a reason, which must not change.
</code></pre>Here, “must not change” means immutable identity (i.e. <code>===</code>), but does not imply deep immutability.</li>
</ol>
</blockquote>
<hr>
<ol start="2">
<li><p><strong>要求</strong><br>2.1. promise的状态<br>   promise只能是<span data-type="color" style="color:#BFBFBF">pending</span>, <span data-type="color" style="color:#73D13D">fulfilled</span>, <span data-type="color" style="color:#FA8C16">rejected</span>三种状态中一种。</p>
<p>   2.1.1. 如果处于<span data-type="color" style="color:#BFBFBF">pending</span>状态，promise:</p>
<pre><code>2.1.1.1. 可以转化为&lt;span data-type=&quot;color&quot; style=&quot;color:#52C41A&quot;&gt;fulfilled&lt;/span&gt;状态或&lt;span data-type=&quot;color&quot; style=&quot;color:#FA8C16&quot;&gt;rejected&lt;/span&gt;状态。
</code></pre><p>   2.1.2. 如果处于<span data-type="color" style="color:#52C41A">fulfilled</span>状态， promise:</p>
<pre><code>2.1.2.1. 不能转化为其他的状态。
2.1.2.2. 必须是不会变化的value。
</code></pre><p>   2.1.3. 如果处于<span data-type="color" style="color:#FA8C16">rejected</span>状态，promise：</p>
<pre><code>2.1.3.1. 不能变成其他的状态。
2.1.3.2. 必须有一个不变的reason。
</code></pre></li>
</ol>
<p>在这里，不变指的是完全不变，（可用===校验），但是不是属性不能变。</p>
<blockquote>
<pre><code>2.2. &lt;strong&gt;The &lt;/strong&gt;&lt;strong&gt;&lt;code&gt;then&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt; Method&lt;/strong&gt;
A promise must provide a `then` method to access its current or eventual value or reason.
A promise’s `then` method accepts two arguments:
</code></pre><p><code>promise.then(onFulfilled, onRejected)</code></p>
<pre><code>2.2.1. Both `onFulfilled` and onRejected are optional arguments:
      2.2.1.1. If onFulfilled is not a function, it must be ignored.
      2.2.1.2. If onRejected is not a function, it must be ignored.

2.2.2. If `onFulfilled` is a function:
      2.2.2.1. it must be called after `promise` is fulfilled, with `promise’s` value as its first argument.
      2.2.2.2. it must not be called before `promise` is fulfilled.
      2.2.2.3. it must not be called more than once.

2.2.3. If `onRejected` is a function,
      2.2.3.1. it must be called after `promise` is rejected, with `promise’s` reason as its first argument.
      2.2.3.2. it must not be called before `promise` is rejected.
      2.2.3.3. it must not be called more than once.

2.2.4. `onFulfilled` or `onRejected` must not be called until the execution context stack contains only platform code. [3.1].

2.2.5. `onFulfilled` and `onRejected` must be called as functions (i.e. with no `this` value). [3.2]

2.2.6. `then` may be called multiple times on the same promise.
     2.2.6.1. If/when `promise` is fulfilled, all respective `onFulfilled` callbacks must execute in the order of their originating calls to `then`.
     2.2.6.2. If/when `promise` is rejected, all respective `onRejected` callbacks must execute in the order of their originating calls to `then`.

2.2.7. then must return a promise [3.3].
         `promise2 = promise1.then(onFulfilled, onRejected);`
     2.2.7.1. If either `onFulfilled` or `onRejected` returns a value `x`, run the Promise Resolution Procedure `[[Resolve]](promise2, x)`.
     2.2.7.2. If either `onFulfilled` or `onRejected` throws an exception `e`, `promise2` must be rejected with `e` as the reason.
     2.2.7.3. If `onFulfilled` is not a function and `promise1` is fulfilled, `promise2` must be fulfilled with the same value as `promise1`.
     2.2.7.4. If `onRejected` is not a function and `promise1` is rejected, `promise2` must be rejected with the same reason as `promise1`.
</code></pre></blockquote>
<hr>
<p>2.2.  <strong>then 方法</strong><br>一个promise必须提供<code>then</code>方法去访问当前或最终的value或者reason。<br>一个promise的<code>then</code>方法接受两个参数：<br><span data-type="color" style="color:rgb(34, 34, 34)"><code>promise.then(onFulfilled,onRejected)</code></span></p>
<pre><code>2.2.1. 如果`onFulfilled`,`onRejected`都是可选参数：
       2.2.1.1. 如果`onFulfilled`不是function，则必须忽略。
       2.2.1.2. 如果`onRejected`不是function, 则必须忽略。

2.2.2. 如果`onFulfilled`是function:
       2.2.2.1. 必须在promise变成&lt;span data-type=&quot;color&quot; style=&quot;color:#73D13D&quot;&gt;fulfilled&lt;/span&gt;状态后被调用，value是调用时的第一个参数。
       2.2.2.2. promise的状态没有变成&lt;span data-type=&quot;color&quot; style=&quot;color:#73D13D&quot;&gt;fulfilled&lt;/span&gt;时绝对不能调用。
       2.2.2.3. 只能被调用一次。

2.2.3. 如果`onRejected`是function:
       2.2.3.1. 必须在promise变成&lt;span data-type=&quot;color&quot; style=&quot;color:#FA8C16&quot;&gt;rejected&lt;/span&gt;状态后被调用，reason是调用时的第一个参数。
       2.2.3.2. promise的状态没有变成&lt;span data-type=&quot;color&quot; style=&quot;color:#FA8C16&quot;&gt;rejected&lt;/span&gt;时绝对不能调用。
       2.2.3.3. 只能被调用一次。

2.2.4. `onFulfilled`或`onRejected`只能在执行环境包含平台代码的情况下。[3.1]

2.2.5. `onFulfilled`或`onRejected`只能作为function调用（不包含this）。[3.2]

2.2.6. `then`可以被一个promise调用多次。
       2.2.6.1. 当promise变成&lt;span data-type=&quot;color&quot; style=&quot;color:#73D13D&quot;&gt;fulfilled&lt;/span&gt;状态时，从一个`then`开始的所有`onFulfilled`方法必须按顺序执行。
       2.2.6.2. 当promise变成&lt;span data-type=&quot;color&quot; style=&quot;color:#FA8C16&quot;&gt;rejected&lt;/span&gt;状态时，从一个`then`开始的所有`onRejected`方法必须按顺序执行。

2.2.7. `then`方法必须返回一个promise。[3.3]
         &lt;span data-type=&quot;color&quot; style=&quot;color:rgb(34, 34, 34)&quot;&gt;&lt;code&gt;promise2=promise1.then(onFulfilled,onRejected);&lt;/code&gt;&lt;/span&gt;
       2.2.7.1. 如果`onFulfilled`或者`onRejected`返回了 value x, 执行Promise 决断过程
                   `[[Resolve]](promise2, x)`
       2.2.7.2. 如果`onFulfilled`或者`onRejected`返回了 exception e, promise2 必须变成&lt;span data-type=&quot;color&quot; style=&quot;color:#FA8C16&quot;&gt;rejected&lt;/span&gt;状态并且使用e作为reason。
       2.2.7.3. 如果`onFulfilled`不是function并且promise1是&lt;span data-type=&quot;color&quot; style=&quot;color:#73D13D&quot;&gt;fulfilled&lt;/span&gt;状态，promise2必须变为&lt;span data-type=&quot;color&quot; style=&quot;color:#73D13D&quot;&gt;fulfilled&lt;/span&gt;状态，并且value与promise1相同。
       2.2.7.4. 如果`onRejected`不是function并且promise1是&lt;span data-type=&quot;color&quot; style=&quot;color:#FA8C16&quot;&gt;rejected&lt;/span&gt;状态，promise2必须变为&lt;span data-type=&quot;color&quot; style=&quot;color:#FA8C16&quot;&gt;rejected&lt;/span&gt;状态，并且reason与promise1相同。
</code></pre><blockquote>
<pre><code>2.3. __The Promise Resolution Procedure__
</code></pre><p>The promise resolution procedure is an abstract operation taking as input a promise and a value, which we denote as <code>[[Resolve]](promise, x)</code>. If <code>x</code> is a thenable, it attempts to make <code>promise</code> adopt the state of <code>x</code>, under the assumption that <code>x</code> behaves at least somewhat like a promise. Otherwise, it fulfills <code>promise</code> with the value <code>x</code>.<br>This treatment of thenables allows promise implementations to interoperate, as long as they expose a Promises/A+-compliant then method. It also allows Promises/A+ implementations to “assimilate” nonconformant implementations with reasonable then methods.<br>      To run <code>[[Resolve]](promise, x)</code>, perform the following steps:<br>      2.3.1. If <code>promise</code> and x refer to the same object, reject <code>promise</code> with a <code>TypeError</code> as the reason.</p>
<pre><code>2.3.2. If `x` is a promise, adopt its state [3.4]:
     2.3.2.1. If `x` is pending, promise must remain pending until `x` is fulfilled or rejected.
     2.3.2.2. If/when `x` is fulfilled, fulfill `promise` with the same value.
     2.3.2.3. If/when `x` is rejected, reject `promise` with the same reason.

2.3.3. Otherwise, `if` x is an object or function,
     2.3.3.1. Let `then` be x.`then`. [3.5]
     2.3.3.2. If retrieving the property `x.then` results in a thrown exception `e`, reject `promise` with `e` as the reason.
     2.3.3.3. If `then` is a function, call it with `x` as `this`, first argument `resolvePromise`, and second argument `rejectPromise`, where:
           2.3.3.3.1. If/when `resolvePromise` is called with a value `y`, run `[[Resolve]](promise, y)`.
           2.3.3.3.2. If/when `rejectPromise` is called with a reason `r`, reject `promise` with `r`.
           2.3.3.3.3. If both `resolvePromise` and `rejectPromise` are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.
           2.3.3.3.4. If calling `then` throws an exception `e`,
                2.3.3.3.4.1. If `resolvePromise` or `rejectPromise` have been called, ignore it.
                2.3.3.3.4.2. Otherwise, reject `promise` with `e` as the reason.
    2.3.3.4. If `then` is not a function, fulfill `promise` with `x`.

2.3.4. If `x` is not an object or function, fulfill `promise` with `x`.
</code></pre><p>If a promise is resolved with a thenable that participates in a circular thenable chain, such that the recursive nature of <code>[[Resolve]](promise, thenable)</code> eventually causes  <code>[[Resolve]](promise, thenable)</code> to be called again, following the above algorithm will lead to infinite</p>
<p>recursion. Implementations are encouraged, but not required, to detect such recursion and reject <code>promise</code> with an informative <code>TypeError</code> as the reason. [3.6]</p>
</blockquote>
<hr>
<p>2.3. Promise的决议过程<br>Promise的决议过程是一个抽象的运算， 输入为 一个promise与一个value值，形式如同<a href="promise, x">[Resolve]</a><br>如果x是thenable的（定义了<code>then</code>方法的object或者function），会尝试使用x的state作为promise的state，前提是x的行为至少像promise，否则，promise使用x去执行。</p>
<p>这种对thenables(包含<code>then</code>方法的object或者function)的处理使得promise的实现变得更灵活， 只要暴露出符合Promises/A+ 的then方法即可。允许Promises/A+ 兼容不合规范的实现。</p>
<p><a href="promise, x">[Resolve]</a>的执行过程如下：<br>2.3.1. 如果promise与x是同一个对象，promise使用TypeError作为reason进行reject。<br>2.3.2. 如果x是一个promise, 判断x的状态：[3.4]<br>       2.3.2.1. 如果x是<span data-type="color" style="color:#BFBFBF">pending</span>状态，promise也必须保持<span data-type="color" style="color:#BFBFBF">pending</span>状态，直到x变为<span data-type="color" style="color:#73D13D">fulfilled</span>或者<span data-type="color" style="color:#FA8C16">rejected</span>。<br>       2.3.2.2. 当x是<span data-type="color" style="color:#73D13D">fulfilled</span>状态，promise使用x的value进行fulfill。<br>       2.3.2.3. 当x是<span data-type="color" style="color:#FA8C16">rejected</span>状态，promise使用x的reason进行reject。</p>
<p>2.3.3. 如果x不是promise，而是object或是function。<br>       2.3.3.1. 使用x.<code>then</code>作为promise的then。[3.5]<br>       2.3.3.2. 如果检索x的<code>then</code>属性出错e，promise使用e做为reason进行reject。<br>       2.3.3.3. 如果<code>then</code>是function，以x为作用域调用<code>then</code>, 像使用this一样，第一个参数是<span data-type="color" style="color:rgb(34, 34, 34)"><span data-type="background" style="background-color:rgb(255, 255, 255)">resolvePromise， 第二个参数是rejectPromise。</span></span><br>                 2.3.3.3.1. 如果<span data-type="color" style="color:rgb(34, 34, 34)"><span data-type="background" style="background-color:rgb(255, 255, 255)">resolvePromise以value y为参数被调用，则执行</span></span><a href="promise, y">[Resolve]</a>。<br>                 2.3.3.3.2. 如果<span data-type="color" style="color:rgb(34, 34, 34)"><span data-type="background" style="background-color:rgb(255, 255, 255)">resolvePromise以reason r为参数被调用，则用r为参数reject promise。</span></span><br>                 2.3.3.3.3. 如果<span data-type="color" style="color:rgb(34, 34, 34)"><span data-type="background" style="background-color:rgb(255, 255, 255)">resolvePromise和rejectPromise都被调用了，或者被同一个参数多次调用，优先执行第一次调用，其余的忽略。</span></span><br>                 2.3.3.3.4. 如果调用<code>then</code>时，扔出错误e。<br>                              2.3.3.3.4.1. 如果<span data-type="color" style="color:rgb(34, 34, 34)"><span data-type="background" style="background-color:rgb(255, 255, 255)">resolvePromise或者rejectPromise已经被调用，忽略他。</span></span><br>                              2.3.3.3.4.2. 否则，以e为reason进行reject。<br>       2.3.3.4. 如果<code>then</code>不是function，promise fulfill x。<br>2.3.4. 如果x不是object或者function，promise fulfill x。</p>
<p>如果promise被一个由thenable组成的循环链resolved，那么promise的决策过程将执行决策过程，造成无限递归。鼓励提供对这种递归的检测并且用TypeError去reject promise，但是不是必须去实现。[3.6]</p>
<blockquote>
<ol start="3">
<li><strong>Notes</strong><br> 3.1 Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that <code>onFulfilled</code> and <code>onRejected</code> execute asynchronously, after the event loop turn in which <code>then</code> is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as <code>setTimeout</code> or <code>setImmediate</code>, or with a “micro-task” mechanism such as <code>MutationObserver</code> or <code>process.nextTick</code>. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.</li>
</ol>
</blockquote>
<hr>
<ol start="3">
<li>附录<br>  3.1. 这里的“平台代码”指的是引擎，环境，promise 实现代码。实际上，要求确保onFulfilled和OnRejected异步执行，在<code>then</code>所在的事件轮询后被调用，并且在新的堆栈中。可以用setTimeout或者setImmediate之类的“宏任务”去实现。或者MutationObserver或者process.nextTick之类的“微任务”去实现。因为promise的实现被认为是平台代码，他可能包含自身任务队列。</li>
</ol>
<p>ps: 异步任务时，JS引擎会将任务划分至macrotask和microtask任务队列，执行一个macrotask的任务后，执行全部的microtask任务，直到所有任务执行完。</p>
<blockquote>
<pre><code>3.2. That is, in strict mode `this` will be `undefined` inside of them; in sloppy mode, it will be the global object.
</code></pre></blockquote>
<hr>
<p>3.2. 也就是说，在严格模式下，this可能为undefined。在马虎模式下，它是全局对象。</p>
<blockquote>
<pre><code>3.3. Implementations may allow `promise2 === promise1`, provided the implementation meets all requirements. Each implementation should document whether it can produce `promise2 === promise1` and under what conditions.
</code></pre></blockquote>
<hr>
<p>3.3. 如果实现所有要求，可能允许promise2 = promise1，但是每个实现上述规则的实例，都应该记录什么情况下才可以产生promise2 === promise1。</p>
<blockquote>
<pre><code>3.4. Generally, it will only be known that `x` is a true promise if it comes from the current implementation. This clause allows the use of implementation-specific means to adopt the state of known-conformant promises.
</code></pre></blockquote>
<hr>
<p>3.4. 只有符合现有规范的才是真正的promise，该条文允许使用特定的实现方式的库接受符合已知promise的state</p>
<blockquote>
<pre><code>3.5  This procedure of first storing a reference to `x.then`, then testing that reference, and then calling that reference, avoids multiple accesses to the `x.then` property. Such precautions are important for ensuring consistency in the face of an accessor property, whose value could change between retrievals.
</code></pre></blockquote>
<hr>
<p>3.5. 决议的过程会先缓存x.then的引用，然后test此引用，然后调用他，避免多次访问他。这种预防措施对确保访问属性的一致性非常重要，因为每次访问的值可能不一样。</p>
<blockquote>
<pre><code>3.6. Implementations should not set arbitrary limits on the depth of thenable chains, and assume that beyond that arbitrary limit the recursion will be infinite. Only true cycles should lead to a `TypeError`; if an infinite chain of distinct thenables is encountered, recursing forever is the correct behavior.
</code></pre></blockquote>
<hr>
<p>3.6. 实现不应该设置thenable链的最大长度，不能假设超过了设置的最大长度就是无限循环的调用。因为只有真正无限递归的调用会扔出TypeError; 如果一个无限链上的每个thenable对象都不同，那他就应该无限调用下去。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>看完了整个标准，只字没提catch这种方法，那么catch和then的区别是什么呢？<br>其实规范的2.2.1. 中说到了promise.then(onFulfilled,onRejected)中的参数适可选的，所以catch应该是then(undefined, onRejected)的一层封装。<br>老规矩，看规范吧~<br><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise.prototype.catch" target="_blank" rel="noopener">Promise.prototype.catch</a></p>
<blockquote>
<p>When the <code>catch</code> method is called with argument onRejected the following steps are taken:</p>
<ol>
<li>Let <em>promise</em> be the <strong>this</strong> value.</li>
<li>Return <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-invoke" target="_blank" rel="noopener">Invoke</a>(<em>promise</em>, <code>&quot;then&quot;</code>, «‍<strong>undefined</strong>, <em>onRejected</em>»).</li>
</ol>
</blockquote>
<p>哈，猜的八九不离十。<br>catch被调用的时候，其实还是执行了一次then，只不过更加语义化地去处理reason。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://nanchenk.github.io/2018/09/06/V8-——-垃圾回收机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nanchen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="噬己心以驽吾翼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/V8-——-垃圾回收机制/" itemprop="url">V8 —— 垃圾回收机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-06T22:35:04+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/06/V8-——-垃圾回收机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/06/V8-——-垃圾回收机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>V8 blog近日发布了文章描述了“并发标记”的新技术，提升标记过程的效率。<br>并发标记是一个主要用新的平行和并发的垃圾收集器替换旧的垃圾回收器的项目，现在Chrome 64和Node.js v10已经默认启用并发标记。讲解之前我们先回顾一下基本知识点。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="弱分代假设（The-Weak-Generational-Hypothesis）"><a href="#弱分代假设（The-Weak-Generational-Hypothesis）" class="headerlink" title="弱分代假设（The Weak Generational Hypothesis）"></a>弱分代假设（<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">The Weak Generational Hypothesis</span></span>）</h3><ol>
<li>多数对象的生命周期短</li>
<li>生命周期长的对象，一般是常驻对象<br>V8的GC也是基于假设将对象分为两代： 新生代和老生代。<br>对不同的分代执行不同的算法可以更有效的执行垃圾回收。</li>
</ol>
<h3 id="新生代与老生代"><a href="#新生代与老生代" class="headerlink" title="新生代与老生代"></a>新生代与老生代</h3><p>新生代包括一个New Space，老生代包括： Old Space, Code Space和Map Space，Large Object Space。<br>64位环境下的V8引擎的新生代内存大小32MB、老生代内存大小为1400MB，而32位则减半，分别为16MB和700MB。<br>对于新生代的对象，采用空间换取时间的Scavenge算法， 尽可能快的回收内存。如果对象经历了2次GC还依然坚挺，就会在第二次回收时晋升为老生代（准确的说是保存在Old Space中）。<br>而老生代的GC采取Mark-Sweep的算法，并使用Mark-Sweep解决内存碎片的问题。</p>
<h3 id="Scavenge算法"><a href="#Scavenge算法" class="headerlink" title="Scavenge算法"></a>Scavenge算法</h3><p><img src="https://cdn.yuque.com/lark/0/2018/png/93051/1529048022543-3a770fc2-029b-4a33-b379-d454103d3890.png" alt="image.png | left | 747x409"></p>
<p>对于新生代对象，采用Scavenge算法来回收。<br>简单来说，将内存的空间分为两个semispace，同一时刻只有一个空间处于使用中。<span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">使用中的叫做 to space，不被使用的叫做 from space。</span></span></p>
<p>分配对象时，先在From空间分配，垃圾回收时检查（宽度优先）From空间的存活对象，将存活对象复制到To空间，清理非存活对象，复制后，空间身份发生对调。</p>
<h3 id="Mark-Sweep算法"><a href="#Mark-Sweep算法" class="headerlink" title="Mark-Sweep算法"></a>Mark-Sweep算法</h3><p><img src="https://cdn.yuque.com/lark/0/2018/png/93051/1529048067558-30b87f25-00e8-44bf-8aa6-be7da34a6609.png" alt="image.png | left | 747x399"></p>
<p>处理老生代对象时，采用深度优先扫描，用三色标记的算法。<br>V8使用每个对象的两个mark-bits和一个标记工作栈来实现标记。<br>两个mark-bits编码三种颜色：白色（00），灰色（10）和黑色（11）。<br>白色表示对象可以回收，黑色表示对象不能回收，并且他的所有引用都被便利完毕了，灰色表示不可回收，他的引用对象没有扫描完毕。<br>扫描过程：</p>
<p><img src="https://cdn.yuque.com/lark/0/2018/gif/93051/1529059110315-9b22551b-dbc7-46a1-ab81-f2b13592f067.gif" alt="Animation_of_tri-color_garbage_collection.gif | center | 330x276"></p>
<ol>
<li>从已知对象开始，即roots(<span data-type="color" style="color:rgb(44, 62, 80)"><span data-type="background" style="background-color:rgb(249, 249, 245)">全局对象和激活函数</span></span>), 将所有非root对象标记置为白色</li>
<li>将root对象的所有直接引用对象入栈（marking worklist）</li>
<li>依次pop出对象，出栈的对象标记为黑，同时将他的直接引用对象标记为灰色并push入栈</li>
<li>栈空的时候，仍然为白色的对象可以回收</li>
<li>回收白色的对象</li>
</ol>
<p>在清除阶段，只清除没被标记的对象。<br>但是进行清除后，内存会出现不连续的状态，对后续的大对象分配地址造成无意义的回收（因为可用内存的不足）,这时就需要Mark-Compact来处理内存碎片了。</p>
<h3 id="Mark-Compact算法"><a href="#Mark-Compact算法" class="headerlink" title="Mark-Compact算法"></a>Mark-Compact算法</h3><p>在对象标记死亡后，在整理的过程中，将活着的对象向另一个内存页移动，移动完后内存页就可以还给操作系统，但如果这一页的活动对象被很多其他页的对象引用，就不会compact，因为移动完后更新其他引用的指针开销大。</p>
<h3 id="全暂停与增量标记"><a href="#全暂停与增量标记" class="headerlink" title="全暂停与增量标记"></a>全暂停与增量标记</h3><p>垃圾回收的3种基本算法需要应用逻辑暂停下来，垃圾回收完后恢复应用程序逻辑，即“全暂停”，过长的停顿会让用户感到卡顿，所以为了降低全堆的垃圾回收，当堆的大小到一定程度后，开始增量GC，V8在标记阶段将标记的动作分为很多小“步进”，应用逻辑与垃圾回收交替进行直到标记阶段完成。<br>但是，对于过大的堆，GC在试图跟上应用程序分配速度的过程中，仍有长时间的停顿，并且应用程序需要通知GC对象图的所有变化，这些都是需要成本的（写保障 write-barrier）。</p>
<p>V8使用Dijkstra-style 的写屏障（write-barrier）来实现通知。<br>当object.field = value in JavaScript时，V8会插入以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called after `object.field = value`.</span></span><br><span class="line">write_barrier(object, field_offset, value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (color(object) == black &amp;&amp; color(value) == white) &#123;</span><br><span class="line">    set_color(value, grey);</span><br><span class="line">    marking_worklist.push(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>write-barrier可以保障不会出现黑色对象指向了白色对象的现象发生（强三色不变形 strong tri-color invariant），这样应用程序不会在GC时误删活动对象。在GC完成后所有白色对象都是可安全删除的。</p>
<p>但是，由于write-barrier的损耗，降低了应用程序的吞吐量，所以需用其他的worker threads提高吞吐量，使worker threads也可以进行标记的工作。这就是下面要讲的平行标记和并发标记。</p>
<h2 id="平行标记-parallel-marking"><a href="#平行标记-parallel-marking" class="headerlink" title="平行标记 parallel marking"></a>平行标记 parallel marking</h2><p><img src="https://cdn.yuque.com/lark/0/2018/png/93051/1529059214916-c14311fa-a628-48cd-bf9c-074f90d0786b.png" alt="image.png | center | 640x129"></p>
<p>平行标记期间，应用程序暂停，main thread和worker thread共同执行标记操作，下图<span data-type="color" style="color:rgb(37, 37, 37)">显示了平行标记所涉及的数据结构。箭头指示数据流的方向。</span></p>
<p><img src="https://cdn.yuque.com/lark/0/2018/png/93051/1529063345805-8ae9b56f-03ca-4d09-881d-6e843ddc9914.png" alt="image.png | center | 640x244"></p>
<p>其中，对象图是只读的，不允许去修改他，Mark-bits和Marking worklist是可以读和写的。<br>Marking worklist负责决定分给其他worker thread的工作量，决定了性能与保持本地线程的均衡，所以如何高效地完成工作的分配至关重要。</p>
<p>如下图所示，V8使用基于内存段的方式去平衡各个线程的工作量，避免线程同步的耗时与尽可能的工作。</p>
<p><img src="https://cdn.yuque.com/lark/0/2018/png/93051/1529064967447-463c1056-21cf-49ed-a81c-03b6c2071041.png" alt="image.png | left | 747x269"></p>
<h2 id="并发标记-concurrent-marking"><a href="#并发标记-concurrent-marking" class="headerlink" title="并发标记 concurrent marking"></a>并发标记 concurrent marking</h2><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.yuque.com/lark/0/2018/png/93051/1529059226036-371bc0b1-33e0-4b9b-8fb7-7568c893f1f3.png" alt="image.png | center | 640x129"></h3><p>并发标记允许标记行为与应用程序同时进行。这就需要解决数据竞争的问题，比如JS代码在更改一个对象的字段，而worker thread又在标记字段，就可能导致错误的垃圾回收。<br>所以main thread需要与worker threads在发生数据竞争时进行同步，大多数的数据竞争行为通过轻量级的原子级内存访问就可以同步，但是一些特殊的场景需要独占整个对象的访问。</p>
<h2 id="优化的结果"><a href="#优化的结果" class="headerlink" title="优化的结果"></a>优化的结果</h2><p><img src="https://cdn.yuque.com/lark/0/2018/png/93051/1529061105900-a09c17ae-2011-486f-bea5-a568c6a942e9.png" alt="image.png | center | 640x228"></p>
<p>有了平行标记与并发标记后，对比上面讲的流程，GC的流程变为：</p>
<ol>
<li>从root对象开始扫描，填充对象到marking worklist</li>
<li>分布并发标记任务到worker threads</li>
<li>worker threads帮助main thread去更快地消费marking worklist中的对象</li>
<li>main thread 偶尔会通过执行bailout worklist 和 marking worklist来marking</li>
<li>一旦marking worklists为空，main thread 就完成GC行为</li>
<li>在结束之前，main thread重新扫描roots，可能会发现其他的白色节点，这些白色节点会在worker threads的帮助下，被平行标记</li>
</ol>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ul>
<li><a href="https://v8project.blogspot.com/2018/06/concurrent-marking.html" target="_blank" rel="noopener">Concurrent marking in V8</a></li>
<li><a href="https://alinode.aliyun.com/blog/37" target="_blank" rel="noopener">解读 V8 GC Log</a></li>
<li>思维导图：<a href="https://github.com/bailinlin/Awsome-Front-End-Xmind" target="_blank" rel="noopener">https://github.com/bailinlin/Awsome-Front-End-Xmind</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://nanchenk.github.io/2018/09/06/javaScript tips——关于下载的二三事/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nanchen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="噬己心以驽吾翼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/javaScript tips——关于下载的二三事/" itemprop="url">JavaScript tips——关于下载的二三事</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-06T22:34:00+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/06/javaScript tips——关于下载的二三事/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/06/javaScript tips——关于下载的二三事/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在项目中经常会遇到下载或导出服务端资源的需求，一般分为2种做法</p>
<ol>
<li>获取文件流，编码后下载</li>
<li>获取文件的url，直接下载<br>本文主要探讨第二种方法，在最后会提及文件流的方法。</li>
</ol>
<h1 id="浏览器的安全策略"><a href="#浏览器的安全策略" class="headerlink" title="浏览器的安全策略"></a>浏览器的安全策略</h1><p>在介绍方法之前，我们需要知道浏览器的一些安全机制，防止恶意代码对用户的破坏。<br>现代浏览器（ie8除外）检测到非用户直接操作产生的新窗口，一般会阻止，比如在ajax的回调中打开<span data-type="color" style="color:#FA8C16">新的窗口</span>，因为这些操作并不是在用户点击的线程中，所以会拦截。</p>
<h1 id="预开新标签页"><a href="#预开新标签页" class="headerlink" title="预开新标签页"></a>预开新标签页</h1><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><ol>
<li>在异步操作之前，先打开一个新标签页</li>
<li>请求后端资源的地址</li>
<li>获取url后去修改空白页的url<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> downloadTab = <span class="built_in">window</span>.open(<span class="string">'about:blank'</span>);</span><br><span class="line"></span><br><span class="line">ajax.get(<span class="string">'xxx'</span>).then(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用后端资源的url进行下载</span></span><br><span class="line">    downloadTab.location.href = href;</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">    downloadTab.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>不管请求成功还是失败都会有新页面的闪烁出现</li>
<li>打开的新页面在什么时候关闭是个问题，因为如果请求时间过长，用户可能自己关闭新页面，更不好处理的情况是页面什么时候触发了下载，因为如果只是更改url就关闭窗口可能还没有开始下载的操作。</li>
</ol>
<h1 id="生成iframe"><a href="#生成iframe" class="headerlink" title="生成iframe"></a>生成iframe</h1><h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><p>为了避免页面闪烁与关闭时机的问题，可以在当前页面使用动态创建iframe的方式，直接下载</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ajax.get(<span class="string">'xxx'</span>).then(<span class="function"><span class="params">href</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!href) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.downIframe) &#123;</span><br><span class="line">      <span class="keyword">this</span>.downIframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>); <span class="comment">// 动态创建iframe</span></span><br><span class="line">      <span class="keyword">this</span>.downIframe.src = href; <span class="comment">// iframe 中加载的页面</span></span><br><span class="line">      <span class="keyword">this</span>.downIframe.id = <span class="string">'downloadIframe'</span>; <span class="comment">// iframe 中加载的页面</span></span><br><span class="line">      <span class="keyword">this</span>.downIframe.style.width = <span class="string">'1px'</span>;</span><br><span class="line">      <span class="keyword">this</span>.downIframe.style.height = <span class="string">'1px'</span>;</span><br><span class="line">      <span class="keyword">this</span>.downIframe.style.position = <span class="string">'absolute'</span>;</span><br><span class="line">      <span class="keyword">this</span>.downIframe.style.left = <span class="string">'-100px'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.downIframe); <span class="comment">// 添加到当前窗体</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.downIframe.src = href; <span class="comment">// iframe 中加载的页面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>虽然可以优雅的下载文件了，可是如果需要定制下载文件的名称就会令人头疼了，我们需要时机去改变下载文件的名称，否则就会使服务端的文件名称。</p>
<h2 id="生成标签"><a href="#生成标签" class="headerlink" title="生成标签"></a>生成<a>标签</a></h2><p>利用download属性设置文件名，</p>
<p><img src="https://cdn.yuque.com/lark/0/2018/png/93051/1529033481407-eb00f8da-bdf5-44f0-9a70-d3e96f1e92f2.png" alt="image.png | left | 747x486"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ajax.get(<span class="string">'xxx'</span>).then(<span class="function"><span class="params">href</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!href) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">var</span> url = href;</span><br><span class="line">    <span class="keyword">var</span> filename = <span class="string">'test.zip'</span>;</span><br><span class="line">    a.href = url;</span><br><span class="line">    a.download = filename; <span class="comment">// 在没有download属性的情况，target="_blank"，仍会阻止打开</span></span><br><span class="line">    a.click();</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意：<br>有些浏览器需要将a标签嵌入页面才可执行。</p>
<h1 id="处理文件流"><a href="#处理文件流" class="headerlink" title="处理文件流"></a>处理文件流</h1><p>最后大概讲一下如果后端返回流怎么处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funDownload</span>(<span class="params">content, filename</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建隐藏的可下载链接</span></span><br><span class="line">    <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">    link.download = filename;</span><br><span class="line">    link.style.display = <span class="string">'none'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符内容转变成blob地址</span></span><br><span class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([content]);</span><br><span class="line">    <span class="comment">//如果是excel格式</span></span><br><span class="line">    <span class="comment">//var blob = new Blob([content], &#123;type: 'application/vnd.ms-excel'&#125;),</span></span><br><span class="line">    link.href = URL.createObjectURL(blob);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发点击</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(link);</span><br><span class="line">    link.click();</span><br><span class="line">    <span class="comment">// 然后移除</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(link);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>URL.createObjectURL() </strong><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">静态方法会创建一个 </span></span><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString" title="DOMString&nbsp;是一个UTF-16字符串。由于JavaScript已经使用了这样的字符串，所以DOMString 直接映射到 一个String。" target="_blank" rel="noopener">DOMString</a><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 </span></span><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document" title="Document 接口提供了一些在浏览器服务中作为页面内容入口点而加载的一些页面，也就是 DOM 树。 DOM 树包括诸如 &lt;body&gt; 和 &lt;table&gt; 之类的元素，及其他元素。其也为文档（document）提供了全局性的函数，例如获取页面的 URL、在文档中创建新的 element&nbsp;的函数。" target="_blank" rel="noopener">document</a><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>绑定。这个新的URL 对象表示指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File" title="文件(File)&nbsp;接口提供有关文件的信息，并允许网页中的 JavaScript 访问其内容。" target="_blank" rel="noopener">File</a><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>对象或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" title="Blob&nbsp;对象表示不可变的类似文件对象的原始数据。Blob表示不一定是JavaScript原生形式的数据。File&nbsp;接口基于Blob，继承了 blob的功能并将其扩展使其支持用户系统上的文件。" target="_blank" rel="noopener">Blob</a><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>对象。</p>
<p>注意：<br><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">在每次调用 </span></span><code>createObjectURL()</code><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)">方法时，都会创建一个新的 URL 对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 </span></span><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL" title="URL.revokeObjectURL() 静态方法用来释放一个之前通过调用&nbsp;URL.createObjectURL() 创建的已经存在的 URL 对象。当你结束使用某个 URL 对象时，应该通过调用这个方法来让浏览器知道不再需要保持这个文件的引用了。" target="_blank" rel="noopener">URL.revokeObjectURL()</a><span data-type="color" style="color:rgb(51, 51, 51)"><span data-type="background" style="background-color:rgb(255, 255, 255)"> </span></span>方法来释放。浏览器会在文档退出的时候自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://nanchenk.github.io/2018/09/06/javaScript tips——谈谈数组乱序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nanchen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="噬己心以驽吾翼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/javaScript tips——谈谈数组乱序/" itemprop="url">javaScript tips——谈谈数组乱序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-06T21:27:59+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/06/javaScript tips——谈谈数组乱序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/06/javaScript tips——谈谈数组乱序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先看一个段代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randArr</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.sort(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目的是为了实现给定数组的乱序。<br>利用数组的sort方法，判断随机出来的0~1的值与0.5的大小，实现伪排序。<br>为什么说是伪排序呢？代码的逻辑没毛病啊。<br>对，从这个层面来看，简单明了，完美的实现了需求，本着凡事往祖坟刨得精神。来看看这段代码的内部实现。</p>
<h2 id="浏览器实现"><a href="#浏览器实现" class="headerlink" title="浏览器实现"></a>浏览器实现</h2><h3 id="ECMA-Script"><a href="#ECMA-Script" class="headerlink" title="ECMA Script"></a>ECMA Script</h3><blockquote>
<p>The elements of this array are sorted. The sort is not necessarily stable (that is, elements that compare equal do not necessarily remain in their original order). If comparefn is not undefined, it should be a function that accepts two arguments x and y and returns a negative value if x &lt; y, zero if x = y, or a positive value if x &gt; y.</p>
</blockquote>
<p>大致说的意思是，我不管你排序的算法稳不稳定，反正你能给用户自定义排序规则就行，不给你就爱咋折腾咋折腾~<br>这帮浏览器一听，好啊，老大发话了，那就八仙过海各显神通，各自都认为自己的实现是最牛逼的。</p>
<h3 id="Chrome的sort"><a href="#Chrome的sort" class="headerlink" title="Chrome的sort"></a>Chrome的sort</h3><p>基于V8引擎，它的排序算进行了很多的优化，但是核心是小于等于10的数组用插入排序（稳定），大于10的采用了quickSort（不稳定），<a href="https://link.juejin.im?target" target="_blank" rel="noopener">源码</a>。</p>
<h3 id="FireFox的sort"><a href="#FireFox的sort" class="headerlink" title="FireFox的sort"></a>FireFox的sort</h3><p>基于SpiderMonkey引擎，采用了归并排序（稳定）， <a href="https://link.juejin.im?target" target="_blank" rel="noopener">源码</a></p>
<h3 id="Safari的sort"><a href="#Safari的sort" class="headerlink" title="Safari的sort"></a>Safari的sort</h3><p>基于Nitro（JavaScriptCore ）引擎，如果没有自定义的排序规则传入，采用桶排序（不一定稳定， 桶排序的稳定性取决于桶内排序的稳定性, 因此其稳定性不确定。），传入自定义规则，采用归并排序（稳定），<a href="https://link.juejin.im?target" target="_blank" rel="noopener">源码</a></p>
<h3 id="Microsoft-Edge-IE9"><a href="#Microsoft-Edge-IE9" class="headerlink" title="Microsoft Edge/IE9+"></a>Microsoft Edge/IE9+</h3><p>基于Chakra引擎，采用快排（不稳定）<a href="https://link.juejin.im?target" target="_blank" rel="noopener">源码</a></p>
<p>好了，那个说sort可以不是伪排序的同学，你看见我这40米的大刀没？<br><img src="https://user-gold-cdn.xitu.io/2018/1/24/161270e19ba7b83f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image | center"></p>
<p>什么，你还嘴硬，我喜欢你的性格，看下面：<br>github上的大神对  var letters = [‘A’,’B’,’C’,’D’,’E’,‘F’,‘G’,’H’,’I’,’J’]；<br>进行了10000次乱序处理，发现结论： <strong>元素大概率停留在自己的初始位置。</strong><br>具体地址： <a href="https://link.juejin.im?target" target="_blank" rel="noopener">HOUCe/shuffle-array</a><br><img src="https://user-gold-cdn.xitu.io/2018/1/24/161270e19bbbfe0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image | center"></p>
<p> 看见没，矮要承认，挨打要立正。<br><img src="https://user-gold-cdn.xitu.io/2018/1/24/161270e19bc17265?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image | center"></p>
<h2 id="洗牌算法（Fisher-Yates）"><a href="#洗牌算法（Fisher-Yates）" class="headerlink" title="洗牌算法（Fisher-Yates）"></a>洗牌算法（Fisher-Yates）</h2><p>想要实现真正意义上的乱序，我们来研究一下：只要满足每个元素出现在各个位置的概率同等即可。<br>少年，听过如来神掌吗？<br>有个<a href="https://link.juejin.im?target" target="_blank" rel="noopener">Fisher-Yates</a>的洗牌算法，满足您的各种乱序需求，物美价廉，杀人越货居家旅行的必备精品~（其实有三个版本，有兴趣的自行搜索）<br>算法的大致描述<br>1.找到数组的屁股（最后一个元素）；<br>2.在脑袋和屁股中间随机一个位置；<br>3.交换元素；<br>4.这时屁股是已经乱序后的元素，所以屁股前移；<br>5.如果屁股没打到脑袋上就继续1~4的步骤<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = arr.length,</span><br><span class="line">        r      = length,</span><br><span class="line">        rand   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (r) &#123;</span><br><span class="line">        rand = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * r--);</span><br><span class="line">        [arr[r], arr[rand]] = [arr[rand], arr[r]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://link.juejin.im?target" target="_blank" rel="noopener"><a href="http://github.com/HOUCe/shuff%E2%80%A6" target="_blank" rel="noopener">github.com/HOUCe/shuff…</a></a><br><a href="https://link.juejin.im?target" target="_blank" rel="noopener"><a href="http://en.wikipedia.org/wiki/Fisher%E2%80%A6" target="_blank" rel="noopener">en.wikipedia.org/wiki/Fisher…</a></a><br><a href="https://link.juejin.im?target" target="_blank" rel="noopener"><a href="http://efe.baidu.com/blog/talk-a%E2%80%A6" target="_blank" rel="noopener">efe.baidu.com/blog/talk-a…</a></a><br><a href="https://link.juejin.im?target" target="_blank" rel="noopener"><a href="http://segmentfault.com/a/119000001%E2%80%A6" target="_blank" rel="noopener">segmentfault.com/a/119000001…</a></a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://nanchenk.github.io/2018/09/06/javaScript tips——消抖（debounce）与节流（throttle）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nanchen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="噬己心以驽吾翼">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/javaScript tips——消抖（debounce）与节流（throttle）/" itemprop="url">javaScript tips: js 消抖（debounce）与节流（throttle）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-06T20:44:25+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/06/javaScript tips——消抖（debounce）与节流（throttle）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/06/javaScript tips——消抖（debounce）与节流（throttle）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>故事发生在与大创的又一次撕逼（日常）中，我方坚定的认为：作为社会主义接班人，节流与消抖的界限是明显的，是不容混肴的，是不可侵犯的！对方辩友坚持地觉得：界限是模糊的，行为是暧昧的，性别是可以忽视的（。。。）。本着凡事要往祖坟上刨的精神，对这两个概念进行了一番深刻的社会主义改造。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p>定义： 如果一个函数持续的，频繁地触发，那么让它在一定的时间间隔后再触发。</p>
<p>感觉像是去排队过安检，当人很多的时候（持续地要进门），安保会隔一段时间放进去几个进行安检（一定时间的间隔）。</p>
<p>类似这种的feel<br><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f268e684250d?w=420&amp;h=236&amp;f=gif&amp;s=1555093" alt="undefined"></p>
<h2 id="消抖（debounce）"><a href="#消抖（debounce）" class="headerlink" title="消抖（debounce）"></a>消抖（debounce）</h2><p>定义： 如果一个函数持续地触发，那么只在它结束后过一段时间只执行一次。</p>
<p>像是两个人的对话，A在不停的balabala（持续触发），如果他说话的时候有停顿（一定间隔），但是停顿的时间不够长，就认为A没有说完， 当停顿时间超过一某个范围就认为A说完了，然后B开始回答（响应）。</p>
<p>场景<br>前提其实都是某个行为持续地触发，不同之处只要判断是要优化到减少它的执行次数还是只执行一次就行。</p>
<p>举个例子，像dom的拖拽，如果用消抖的话，就会出现卡顿的感觉，因为只在停止的时候执行了一次，这个时候就应该用节流，在一定时间内多次执行，会流畅很多。</p>
<p>但是，如果是输入联想这种，我要输入“谁是世界上最帅的人？”，多次执行的话，可能当我输到最的时候，就去搜索，结果搜出来一堆“谁是世界上最笨”，“谁是世界上最胖”之类的不必要搜索，只需要在输入完成后进行搜索，消抖当时最合适啦。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>明白了定义与场景，让我们脱下裤子， 呸 撸起袖子来造一个。</p>
<p>先看看名家手笔</p>
<p>underscore的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// Returns a function, that, as long as it continues to be invoked, will not</span><br><span class="line">// be triggered. The function will be called after it stops being called for</span><br><span class="line">// N milliseconds. If `immediate` is passed, trigger the function on the</span><br><span class="line">// leading edge, instead of the trailing.</span><br><span class="line">_.debounce = function(func, wait, immediate) &#123;</span><br><span class="line">  var timeout, result;</span><br><span class="line"></span><br><span class="line">  var later = function(context, args) &#123;</span><br><span class="line">    timeout = null;</span><br><span class="line">    if (args) result = func.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var debounced = restArgs(function(args) &#123;</span><br><span class="line">    if (timeout) clearTimeout(timeout);</span><br><span class="line">    if (immediate) &#123;</span><br><span class="line">      var callNow = !timeout;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">      if (callNow) result = func.apply(this, args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      timeout = _.delay(later, wait, this, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  debounced.cancel = function() &#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    timeout = null;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return debounced;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Returns a function, that, when invoked, will only be triggered at most once</span><br><span class="line">// during a given window of time. Normally, the throttled function will run</span><br><span class="line">// as much as it can, without ever going more than once per `wait` duration;</span><br><span class="line">// but if you&apos;d like to disable the execution on the leading edge, pass</span><br><span class="line">// `&#123;leading: false&#125;`. To disable execution on the trailing edge, ditto.</span><br><span class="line">_.throttle = function(func, wait, options) &#123;</span><br><span class="line">  var timeout, context, args, result;</span><br><span class="line">  var previous = 0;</span><br><span class="line">  if (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  var later = function() &#123;</span><br><span class="line">    previous = options.leading === false ? 0 : _.now();</span><br><span class="line">    timeout = null;</span><br><span class="line">    result = func.apply(context, args);</span><br><span class="line">    if (!timeout) context = args = null; //显示地释放内存，防止内存泄漏</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var throttled = function() &#123;</span><br><span class="line">    var now = _.now();</span><br><span class="line">    if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class="line">    var remaining = wait - (now - previous);</span><br><span class="line">    context = this;</span><br><span class="line">    args = arguments;</span><br><span class="line">    if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">      if (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = null;</span><br><span class="line">      &#125;</span><br><span class="line">      previous = now;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      if (!timeout) context = args = null;</span><br><span class="line">    &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">      timeout = setTimeout(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  throttled.cancel = function() &#123;</span><br><span class="line">    clearTimeout(timeout);</span><br><span class="line">    previous = 0;</span><br><span class="line">    timeout = context = args = null;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return throttled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实现了更灵活的option去控制是否立即执行，是否劫数是在执行以及增加cancel的控制逻辑。本着大道至简的精神（其实是懒），我们来改一个精简版只实现基本业务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">function debounce (fn, delay) &#123;</span><br><span class="line">    let args    = arguments,</span><br><span class="line">       context = this,</span><br><span class="line">        timer   = null;</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">	   args    = arguments；</span><br><span class="line">       context = this；</span><br><span class="line"></span><br><span class="line">        if (timer) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line"></span><br><span class="line">            timer = setTimeout(function () &#123;</span><br><span class="line">                fn.apply(context, args);</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            timer = setTimeout(function () &#123;</span><br><span class="line">                fn.apply(context, args);</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function throttle (fn, delay) &#123;</span><br><span class="line">    let args      = arguments,</span><br><span class="line">        context   = this,</span><br><span class="line">        timer     = null,</span><br><span class="line">        remaining = 0,</span><br><span class="line">        previous  = new Date();</span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        let now   = new Date();</span><br><span class="line">        remaining = now - previous;</span><br><span class="line">		context   = this;</span><br><span class="line">		args      = arguments;</span><br><span class="line"></span><br><span class="line">        if (remaining &gt;= delay) &#123;</span><br><span class="line">            if (timer) &#123;</span><br><span class="line">                clearTimeout(timer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (!timer) &#123;</span><br><span class="line">                timer = setTimeout(function () &#123;</span><br><span class="line">                    fn.apply(context, args);</span><br><span class="line">                    previous = new Date();</span><br><span class="line">                &#125;, delay - remaining);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>红宝书上给的节流例子，嗯。。。怎么说呢。。。 是非常棒的消抖的实现，(╯‵□′)╯︵┻━┻谢谢！！！！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="Nanchen" />
            
              <p class="site-author-name" itemprop="name">Nanchen</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:vincentlittleguy@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nanchen</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ant"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  


















  





  

  

  

  
  

  

  

  

</body>
</html>
